
/** A wrapper around a value. */
export type Holder<T, Prop extends string | symbol = "value"> = {
  [P in Prop]: T;
}

/** Maps an interface to a collection of Holders. For example,
 *  `Holders<{ foo: number, bar: string }>` means 
 *  `{ foo: Holder<number>, bar: Holder<string> }`. */
export type Holders<Model> = {
  // "-?" avoids the default behavior that `foo?:T` maps to 
  // `foo?:Holder<T|undefined>` instead of `foo:Holder<T|undefined>`
  [P in keyof Model]-?: Holder<Model[P]>;
}

/** A helper function that bundles a getter and setter into a Holder object.
 *  For example, `hold(model, "foo").value` returns the value of `model.foo`, 
 *  and `hold(model, "foo").set("newVal")` changes the value of `model.foo`
 *  to "newVal". If a third argument `onChange` is provided, it is called 
 *  before (or instead of) updating the model. For example, the following 
 *  code creates a reference called `foo` so that if you write 
 *  `foo.set("YES")`, the callback executes `this.setState({ foo: "YES" })`:
 *  
 *      var onChange = (attr:any, newVal:any) => {
 *        this.setState({ [attr]: newVal });
 *      };
 *      var foo = hold(this.state, "foo", onChange);
 * 
 *  @param model An object that contains a property you want to bind.
 *  @param attr  The name of a property of `model` that you want to bind.
 *  @param onChange A function that will be called later, when the return
 *         value's `val` property is changed. The first argument is the
 *         value of `attr` (usually a string), and the second argument is
 *         the value assigned to the Holder's val. `onChange` can return
 *         `true` to cause the default change behavior, i.e. 
 *         `model[attr] = newValue`.
 */
export function hold<T, Attr extends keyof T>(model: T, attr: Attr, onChange: ((attr: Attr, newValue: T[Attr]) => void|boolean) | undefined): Holder<T[Attr]>
{
  return new Hold(model, attr, onChange);
}

export class Hold<T, Attr extends keyof T> implements Holder<T[Attr]>
{
  constructor(public model: T, public attr: Attr, public onChange?: (attr:Attr, newValue:T[Attr])=>void|boolean) {}
  get value() {
    return this.model[this.attr];
  }
  set value(newValue: any) {
    if (!this.onChange || this.onChange.call(this.model, this.attr, newValue))
      this.model[this.attr] = newValue;
  }
  clone() {
    return new Hold(this.model, this.attr, this.onChange);
  }
}

/** Represents a React/preact component with a state property and setState method. */
export type StatefulComponent<S> = {
  state: S, setState: (s: any/*Partial<S>*/) => any
};

/**
 * Returns a default change handler for React/preact component state. Writing
 * 
 *     var onChange = onChangeStateOf(this);
 * 
 * is a shortcut for
 * 
 *     var onChange = (attr: string, newValue: any) => {
 *       this.setState({ [attr]: newValue } as any);
 *     };
 */
export function onChangeStateOf<This extends StatefulComponent<S>, S=This["state"]>(_this: This)
{
  return (attr: keyof S, newValue: any) => {
    _this.setState({ [attr]: newValue });
  };
}

/**
 * Returns a default change handler for React/preact component state, in
 * the special case that your state is a cloneable Holder object (such as 
 * an object generated by hold()) but the actual model is mutable and is
 * located outside the React component hierarchy, and e.g. received via
 * props.
 * 
 * It is intended to be used in a situation where your component state
 * mirrors the external model, like this:
 * 
 *     var onChange = onChangeHeldStateOf(this);
 *     this.state.foo = hold(props.model, 'foo', onChange);
 * 
 * is a shortcut for this code:
 * 
 *     var onChange = (attr: string, newValue: any) => {
 *       // Set this.state[name] to a clone of itself. The purpose of 
 *       // doing this is to allow shallow comparisons to detect the 
 *       // change in state, in case the user is using something like 
 *       // Pure Components which only update when the state changes.
 *       var prop = (this.state as any)[name];
 *       _this.setState({ [name]: prop.clone ? prop.clone() : prop } as any);
 *       // Ask holder to change the underlying model
 *       return true;
 *     };
 * 
 * When you use this function, the property (`foo` in this example) must
 * exist in both `this.state` and the model (`props.model` in this 
 * example).
 */
export function onChangeHeldStateOf<This extends StatefulComponent<S>, S=This["state"]>(_this: This)
{
  return (attr: keyof S, newValue: any) => {
      var prop = (_this.state as any)[name];
      _this.setState({ [name]: prop.clone ? prop.clone() : prop } as any);
      return true;
  };
}

/**
 * A helper function for using `hold()` a component's state in React. 
 * If you write 
 * 
 *     var hstate = holdState(this as MyClass); // cast as its own type
 *     var foo = hstate("foo");
 *     var bar = hstate("bar");
 * 
 * where ThisClass is the type of this (TypeScript fails to infer it),
 * it is equivalent to
 * 
 *     var onChange = (attr:any, newVal:any) => {
 *       this.setState({ [attr]: newVal });
 *     };
 *     var foo = hold(this.state, "foo", onChange);
 *     var bar = hold(this.state, "bar", onChange);
 */
export function holdState<This extends StatefulComponent<S>, S=This["state"]>
  (component: This): <Attr extends keyof State>(attr: Attr) => Holder<State[Attr]>
{
  return function<Attr extends keyof State>(attr: Attr) {
    return hold(component.state, attr, onChangeStateOf(component));
  };
}

/** Given an object and a list of property names, constructs a new 
 *  object with a Holder wrapping each property of the object. */
export function holdProps<T, Props extends keyof T>
  (model: T, propNames: Props[], onChange: ((attr: Props, newValue: T[Props]) => void|boolean) | undefined):
  { [P in Props]-?: Holder<T[P]> }
{
  return propNames.reduce((out,k) => (out[k] = hold(model, k, onChange), out),
    {} as { [P in Props]-?: Holder<T[P]> });
}

/** Given an object, constructs a new object with a Holder wrapping each 
 *  enumerable property of the original object. */
export function holdAllProps<T>(model: T, onChange: (<A extends keyof T>(attr: A, newValue: T[A]) => void|boolean) | undefined): Holders<T>
{
  return holdProps(model, Object.keys(model) as (keyof T)[], onChange);
}
